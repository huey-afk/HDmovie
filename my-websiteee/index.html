<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StreamFlix - A Multi-Server Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #141414; /* Netflix black */
        }
        #heroSection {
            transition: background-image 0.5s ease-in-out;
        }
        .hero-gradient {
            background-image: linear-gradient(to top, #141414, rgba(20, 20, 20, 0) 50%);
        }
        .movie-card {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .movie-card:hover {
            transform: scale(1.05);
            z-index: 10;
        }
        .movie-carousel {
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none;  /* Internet Explorer 10+ */
        }
        .movie-carousel::-webkit-scrollbar {
            display: none; /* Safari and Chrome */
        }
        .modal.hidden {
            display: none;
        }
        .carousel-container:hover .scroll-btn {
            opacity: 1;
        }
        .scroll-btn {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 50px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            cursor: pointer;
            z-index: 20;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            padding-bottom: 1rem; /* To align with the padding of the carousel */
        }
        .scroll-btn.left {
            left: 0;
            border-top-right-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }
        .scroll-btn.right {
            right: 0;
            border-top-left-radius: 0.5rem;
            border-bottom-left-radius: 0.5rem;
        }
        #player-iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        .server-btn.active {
            background-color: #e50914;
            color: white;
            font-weight: 700;
        }
    </style>
</head>
<body class="text-gray-200">

    <!-- Header / Navbar -->
    <header class="fixed top-0 left-0 right-0 z-50 p-4 transition-colors duration-300 bg-gradient-to-b from-black/80 to-transparent">
        <div class="w-full mx-auto flex items-center justify-between px-4 md:px-8">
            <h1 class="text-2xl md:text-3xl font-extrabold text-red-600 tracking-wider">STREAMFLIX</h1>
            <div class="flex items-center gap-4">
                <div class="flex items-center gap-4 bg-gray-900/50 border border-gray-700 rounded-full px-3 py-1.5">
                    <input type="text" id="searchInput" placeholder="Search movies & series..." class="bg-transparent text-white placeholder-gray-400 focus:outline-none w-32 sm:w-48 md:w-64">
                    <button id="searchBtn">
                        <i data-lucide="search" class="w-5 h-5 text-gray-400 hover:text-white transition-colors"></i>
                    </button>
                </div>
            </div>
        </div>
    </header>

    <main class="pt-24">
        <!-- Hero Section -->
        <section id="heroSection" class="relative h-[40vh] md:h-[50vh] flex items-end text-white p-6 md:p-12" style="background-image: url('https://placehold.co/1920x1080/141414/141414?text='); background-size: cover; background-position: center top;">
             <div class="absolute inset-0 hero-gradient"></div>
             <div class="relative z-10 max-w-xl lg:max-w-3xl px-4 md:px-8">
                <h2 id="heroTitle" class="text-3xl md:text-5xl font-extrabold drop-shadow-lg">Loading...</h2>
                <p id="heroOverview" class="mt-4 text-xs md:text-sm max-w-prose drop-shadow-md">
                    Fetching the latest content for you.
                </p>
            </div>
        </section>
        
        <div id="errorMessage" class="my-4 text-red-500 text-center font-medium container mx-auto"></div>
        
        <!-- Movie Rows Container -->
        <div id="movieRows" class="space-y-12 py-8 px-4 md:px-8">
             <!-- Rows will be injected here -->
        </div>
    </main>

    <!-- Player Modal -->
    <div id="playerModal" class="modal hidden fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4 backdrop-blur-sm">
        <div class="relative w-full max-w-screen-xl bg-gray-900 rounded-xl shadow-2xl overflow-hidden flex flex-col max-h-[95vh]">
            <button id="closePlayerModalBtn" class="absolute top-3 right-3 z-20 text-gray-400 hover:text-white bg-black/50 rounded-full p-1">
                <i data-lucide="x" class="w-7 h-7"></i>
            </button>
            <div id="playerContainer" class="w-full aspect-video bg-black flex items-center justify-center">
                <iframe id="player-iframe" allowfullscreen></iframe>
            </div>
            <div class="flex flex-col p-4 bg-gray-800">
                <h2 id="modalMovieTitle" class="text-2xl font-bold text-white mb-4"></h2>
                 <div id="serversList" class="flex flex-wrap gap-2 mb-4">
                    <!-- Server buttons will be injected here -->
                </div>
                <!-- TV Show Controls -->
                <div id="tvControls" class="hidden items-center gap-4">
                     <div>
                        <label for="seasonInput" class="text-sm font-medium text-gray-400">Season</label>
                        <input type="number" id="seasonInput" value="1" min="1" class="w-20 bg-gray-700 border border-gray-600 text-white rounded-lg px-2 py-1 focus:ring-2 focus:ring-red-500 focus:outline-none">
                     </div>
                     <div>
                        <label for="episodeInput" class="text-sm font-medium text-gray-400">Episode</label>
                        <input type="number" id="episodeInput" value="1" min="1" class="w-20 bg-gray-700 border border-gray-600 text-white rounded-lg px-2 py-1 focus:ring-2 focus:ring-red-500 focus:outline-none">
                     </div>
                     <button id="loadEpisodeBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg self-end">Load Episode</button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        lucide.createIcons();
        
        // --- CONFIGURATION ---
        const TMDB_API_KEY = 'a1e72fd93ed59f56e6332813b9f8dcae';
        const SERVERS = [
            { name: "Server 1", type: 'vidsrc', movieUrl: "https://vidsrc.cc/v2/embed/movie/{id}", tvUrl: "https://vidsrc.cc/v2/embed/tv/{id}" },
            { name: "Server 2", type: 'vidsrc', movieUrl: "https://vidsrc.cc/v3/embed/movie/{id}", tvUrl: "https://vidsrc.cc/v3/embed/tv/{id}" },
            { name: "Server 3", type: 'autoembed', movieUrl: "https://player.autoembed.cc/embed/movie/{id}", tvUrl: "https://player.autoembed.cc/embed/tv/{id}/{season}/{episode}" }
        ];

        // --- CONSTANTS ---
        const TMDB_API_BASE = 'https://api.themoviedb.org/3';
        const TMDB_IMAGE_BASE_POSTER = 'https://image.tmdb.org/t/p/w500';
        const TMDB_IMAGE_BASE_BACKDROP = 'https://image.tmdb.org/t/p/original';

        // --- DOM Elements ---
        const searchInput = document.getElementById('searchInput');
        const searchBtn = document.getElementById('searchBtn');
        const errorMessage = document.getElementById('errorMessage');
        const movieRowsContainer = document.getElementById('movieRows');
        const playerModal = document.getElementById('playerModal');
        const closePlayerModalBtn = document.getElementById('closePlayerModalBtn');
        const serversList = document.getElementById('serversList');
        const modalMovieTitle = document.getElementById('modalMovieTitle');
        const heroSection = document.getElementById('heroSection');
        const heroTitle = document.getElementById('heroTitle');
        const heroOverview = document.getElementById('heroOverview');
        const playerIframe = document.getElementById('player-iframe');
        const tvControls = document.getElementById('tvControls');
        const seasonInput = document.getElementById('seasonInput');
        const episodeInput = document.getElementById('episodeInput');
        const loadEpisodeBtn = document.getElementById('loadEpisodeBtn');
        
        let currentMedia = null;
        let activeServer = null;

        // --- EVENT LISTENERS ---
        searchBtn.addEventListener('click', searchContent);
        searchInput.addEventListener('keyup', e => e.key === 'Enter' && searchContent());
        closePlayerModalBtn.addEventListener('click', closeModal);
        playerModal.addEventListener('click', e => e.target === playerModal && closeModal());
        loadEpisodeBtn.addEventListener('click', loadSelectedEpisode);
        
        // --- CORE LOGIC ---

        function loadPlayerForMedia(media) {
            openModal(playerModal);
            currentMedia = media;
            modalMovieTitle.textContent = media.title || media.name;
            serversList.innerHTML = '';
            playerIframe.src = 'about:blank';
            tvControls.style.display = 'none';

            SERVERS.forEach((server, index) => {
                const serverBtn = document.createElement('button');
                serverBtn.textContent = server.name;
                serverBtn.className = 'server-btn bg-gray-700 hover:bg-red-700 text-gray-200 font-semibold py-2 px-4 rounded-lg transition-colors';
                serverBtn.addEventListener('click', () => {
                    loadStream(server);
                    document.querySelectorAll('.server-btn').forEach(btn => btn.classList.remove('active'));
                    serverBtn.classList.add('active');
                });
                serversList.appendChild(serverBtn);
                
                if (index === 0) {
                    serverBtn.click();
                }
            });
        }

        function loadStream(server) {
            activeServer = server;
            if (!currentMedia) return;

            if (currentMedia.media_type === 'tv') {
                if (server.type === 'autoembed') {
                    tvControls.style.display = 'flex';
                    seasonInput.value = 1;
                    episodeInput.value = 1;
                    loadSelectedEpisode();
                } else {
                    tvControls.style.display = 'none';
                    const url = server.tvUrl.replace('{id}', currentMedia.id);
                    playerIframe.src = url;
                }
            } else { // Movie
                tvControls.style.display = 'none';
                const url = server.movieUrl.replace('{id}', currentMedia.id);
                playerIframe.src = url;
            }
        }

        function loadSelectedEpisode() {
            if (!currentMedia || currentMedia.media_type !== 'tv' || !activeServer || activeServer.type !== 'autoembed') return;
            const season = seasonInput.value;
            const episode = episodeInput.value;
            const url = activeServer.tvUrl.replace('{id}', currentMedia.id).replace('{season}', season).replace('{episode}', episode);
            playerIframe.src = url;
        }

        async function fetchCombinedAndDisplay(movieEndpoint, tvEndpoint, title) {
            try {
                const movieUrl = `${TMDB_API_BASE}/${movieEndpoint}?api_key=${TMDB_API_KEY}&language=en-US&page=1`;
                const tvUrl = `${TMDB_API_BASE}/${tvEndpoint}?api_key=${TMDB_API_KEY}&language=en-US&page=1`;

                const [movieResponse, tvResponse] = await Promise.all([fetch(movieUrl), fetch(tvUrl)]);
                if (!movieResponse.ok || !tvResponse.ok) throw new Error(`TMDB API Error`);

                const movieData = await movieResponse.json();
                const tvData = await tvResponse.json();

                const movies = movieData.results.map(m => ({...m, media_type: 'movie'}));
                const series = tvData.results.map(t => ({...t, media_type: 'tv'}));

                let combined = [...movies, ...series].sort((a, b) => b.popularity - a.popularity);

                if (combined.length > 0) createMovieRow(title, combined);
            } catch (error) {
                console.error(`Error fetching combined for ${title}:`, error);
                displayError(error.message);
            }
        }
        
        async function fetchAndDisplay(endpoint, title, mediaType) {
            try {
                const url = `${TMDB_API_BASE}/${endpoint}?api_key=${TMDB_API_KEY}&language=en-US&page=1`;
                const response = await fetch(url);
                if (!response.ok) throw new Error(`TMDB API Error: ${response.statusText}`);
                const data = await response.json();
                if (data.results && data.results.length > 0) {
                     const contentResults = data.results.map(item => ({...item, media_type: mediaType}));
                     createMovieRow(title, contentResults);
                     
                     if (endpoint.includes('trending/movie')) {
                         const heroItem = contentResults[0];
                         if (heroItem && heroItem.backdrop_path) {
                            heroSection.style.backgroundImage = `url('${TMDB_IMAGE_BASE_BACKDROP}${heroItem.backdrop_path}')`;
                            heroTitle.textContent = heroItem.title || heroItem.name;
                            heroOverview.textContent = heroItem.overview;
                         }
                     }
                }
            } catch (error) {
                console.error(`Error fetching ${title}:`, error);
                displayError(error.message);
            }
        }
        
        async function searchContent() {
            const query = searchInput.value.trim();
            if (!query) { displayError("Please enter a title."); return; }
            const existingSearchRow = document.getElementById('search-results-row');
            if(existingSearchRow) existingSearchRow.remove();
            
            const loadingIndicator = document.createElement('div');
            loadingIndicator.id = 'search-loading';
            loadingIndicator.innerHTML = `<h2 class="text-2xl font-bold mb-4">Searching...</h2>`;
            movieRowsContainer.prepend(loadingIndicator);
            try {
                const searchUrl = `${TMDB_API_BASE}/search/multi?api_key=${TMDB_API_KEY}&query=${encodeURIComponent(query)}`;
                const response = await fetch(searchUrl);
                if (!response.ok) throw new Error(`TMDB API Error`);
                const data = await response.json();
                
                document.getElementById('search-loading')?.remove();
                
                const contentResults = data.results.filter(item => item.media_type === 'movie' || item.media_type === 'tv');

                if (contentResults.length > 0) {
                    createMovieRow('Search Results', contentResults, 'search-results-row');
                } else {
                    displayError('No movies or series found for that query.');
                }
            } catch (error) {
                console.error("Search error:", error);
                displayError(error.message);
            }
        }
        function createMovieRow(title, mediaItems, rowId = '') {
            const rowWrapper = document.createElement('div');
            if (rowId) rowWrapper.id = rowId;
            rowWrapper.innerHTML = `
                <h2 class="text-2xl font-bold mb-4">${title}</h2>
                <div class="carousel-container relative">
                    <div class="movie-carousel flex overflow-x-auto space-x-4 pb-4"></div>
                    <button class="scroll-btn left"><i data-lucide="chevron-left" class="w-8 h-8"></i></button>
                    <button class="scroll-btn right"><i data-lucide="chevron-right" class="w-8 h-8"></i></button>
                </div>`;
            const carousel = rowWrapper.querySelector('.movie-carousel');
            mediaItems.forEach(media => {
                if (!media.poster_path) return;
                const movieCard = document.createElement('div');
                movieCard.className = 'movie-card flex-shrink-0 w-32 sm:w-36 md:w-40 lg:w-44 xl:w-52 bg-gray-800 rounded-lg overflow-hidden cursor-pointer';
                movieCard.innerHTML = `<img src="${TMDB_IMAGE_BASE_POSTER}${media.poster_path}" alt="${media.title || media.name}" class="w-full h-auto">`;
                movieCard.addEventListener('click', () => loadPlayerForMedia(media));
                movieCard.addEventListener('mouseenter', () => debouncedUpdateHero(media));
                carousel.appendChild(movieCard);
            });
            const leftBtn = rowWrapper.querySelector('.scroll-btn.left');
            const rightBtn = rowWrapper.querySelector('.scroll-btn.right');
            leftBtn.addEventListener('click', () => carousel.scrollBy({ left: -carousel.offsetWidth * 0.9, behavior: 'smooth' }));
            rightBtn.addEventListener('click', () => carousel.scrollBy({ left: carousel.offsetWidth * 0.9, behavior: 'smooth' }));
            lucide.createIcons({ nodes: [leftBtn, rightBtn] });
            if(rowId === 'search-results-row'){ movieRowsContainer.prepend(rowWrapper); } 
            else { movieRowsContainer.appendChild(rowWrapper); }
        }

        // --- UTILITY AND HELPER FUNCTIONS ---

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => { clearTimeout(timeout); func(...args); };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function updateHero(media) {
            if (media && media.backdrop_path) {
                heroSection.style.backgroundImage = `url('${TMDB_IMAGE_BASE_BACKDROP}${media.backdrop_path}')`;
                heroTitle.textContent = media.title || media.name;
                heroOverview.textContent = media.overview;
            }
        }

        const debouncedUpdateHero = debounce(updateHero, 300);

        function openModal(modal) {
            modal.classList.remove('hidden');
            document.body.style.overflow = 'hidden';
        }
        function closeModal() {
            playerIframe.src = 'about:blank'; // Stop video on close
            currentMedia = null; // Clear current media
            playerModal.classList.add('hidden');
            document.body.style.overflow = 'auto';
        }
        function displayError(message) { 
            errorMessage.textContent = message;
            setTimeout(() => errorMessage.textContent = '', 5000);
        }

        // --- INITIALIZATION ---
        function initializeApp() {
             if (!TMDB_API_KEY) { displayError("CRITICAL: TMDB API Key not set."); return; }
            fetchAndDisplay('trending/movie/week', 'Trending Movies', 'movie');
            fetchAndDisplay('trending/tv/week', 'Trending Series', 'tv');
            fetchCombinedAndDisplay('movie/popular', 'tv/popular', 'Popular Movies & Series');
            fetchAndDisplay('movie/now_playing', 'Newest Movies', 'movie');
            fetchAndDisplay('tv/on_the_air', 'Newest TV Series', 'tv');
        }

        initializeApp();
    </script>
</body>
</html>

